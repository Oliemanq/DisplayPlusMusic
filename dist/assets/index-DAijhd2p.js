(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))s(a);new MutationObserver(a=>{for(const r of a)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(a){const r={};return a.integrity&&(r.integrity=a.integrity),a.referrerPolicy&&(r.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?r.credentials="include":a.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(a){if(a.ep)return;a.ep=!0;const r=t(a);fetch(a.href,r)}})();class i{api;constructor(e){this.api=e}async getRequest(e){return await this.api.makeRequest("GET",e)}async postRequest(e,t,s=void 0){return await this.api.makeRequest("POST",e,t,s)}async putRequest(e,t,s=void 0){return await this.api.makeRequest("PUT",e,t,s)}async deleteRequest(e,t){return await this.api.makeRequest("DELETE",e,t)}paramsFor(e){const t=new URLSearchParams;for(let s of Object.getOwnPropertyNames(e))(e[s]||e[s]===0||!e[s]&&typeof e[s]=="boolean")&&t.append(s,e[s].toString());return[...t].length>0?`?${t.toString()}`:""}}class $ extends i{async get(e,t){if(typeof e=="string"){const r=this.paramsFor({market:t});return await this.getRequest(`albums/${e}${r}`)}const s=this.paramsFor({ids:e,market:t});return(await this.getRequest(`albums${s}`)).albums}tracks(e,t,s,a){const r=this.paramsFor({market:t,limit:s,offset:a});return this.getRequest(`albums/${e}/tracks${r}`)}}class q extends i{async get(e){if(typeof e=="string")return this.getRequest(`artists/${e}`);const t=this.paramsFor({ids:e});return(await this.getRequest(`artists${t}`)).artists}albums(e,t,s,a,r){const o=this.paramsFor({include_groups:t,market:s,limit:a,offset:r});return this.getRequest(`artists/${e}/albums${o}`)}topTracks(e,t){const s=this.paramsFor({market:t});return this.getRequest(`artists/${e}/top-tracks${s}`)}relatedArtists(e){return this.getRequest(`artists/${e}/related-artists`)}}class x extends i{async get(e,t){if(typeof e=="string"){const r=this.paramsFor({market:t});return this.getRequest(`audiobooks/${e}${r}`)}const s=this.paramsFor({ids:e,market:t});return(await this.getRequest(`audiobooks${s}`)).audiobooks}getAudiobookChapters(e,t,s,a){const r=this.paramsFor({market:t,limit:s,offset:a});return this.getRequest(`audiobooks/${e}/chapters${r}`)}}class F extends i{getCategories(e,t,s,a){const r=this.paramsFor({country:e,locale:t,limit:s,offset:a});return this.getRequest(`browse/categories${r}`)}getCategory(e,t,s){const a=this.paramsFor({country:t,locale:s});return this.getRequest(`browse/categories/${e}${a}`)}getNewReleases(e,t,s){const a=this.paramsFor({country:e,limit:t,offset:s});return this.getRequest(`browse/new-releases${a}`)}getFeaturedPlaylists(e,t,s,a,r){const o=this.paramsFor({country:e,locale:t,timestamp:s,limit:a,offset:r});return this.getRequest(`browse/featured-playlists${o}`)}getPlaylistsForCategory(e,t,s,a){const r=this.paramsFor({country:t,limit:s,offset:a});return this.getRequest(`browse/categories/${e}/playlists${r}`)}}class v extends i{async get(e,t){if(typeof e=="string"){const r=this.paramsFor({market:t});return this.getRequest(`chapters/${e}${r}`)}const s=this.paramsFor({ids:e,market:t});return(await this.getRequest(`chapters${s}`)).chapters}}class A extends i{async get(e,t){if(typeof e=="string"){const r=this.paramsFor({market:t});return this.getRequest(`episodes/${e}${r}`)}const s=this.paramsFor({ids:e,market:t});return(await this.getRequest(`episodes${s}`)).episodes}}class E extends i{get(e){const t=this.paramsFor(e);return this.getRequest(`recommendations${t}`)}genreSeeds(){return this.getRequest("recommendations/available-genre-seeds")}}class P extends i{getAvailableMarkets(){return this.getRequest("markets")}}class I extends i{getPlaybackState(e,t){const s=this.paramsFor({market:e,additional_types:t});return this.getRequest(`me/player${s}`)}getAvailableDevices(){return this.getRequest("me/player/devices")}getCurrentlyPlayingTrack(e,t){const s=this.paramsFor({market:e,additional_types:t});return this.getRequest(`me/player/currently-playing${s}`)}getRecentlyPlayedTracks(e,t){const s={limit:e};t&&(t.type==="before"?s.before=t.timestamp:t.type==="after"&&(s.after=t.timestamp));const a=this.paramsFor(s);return this.getRequest(`me/player/recently-played${a}`)}getUsersQueue(){return this.getRequest("me/player/queue")}async transferPlayback(e,t){if(e.length>1)throw new Error("Although an array is accepted, only a single device_id is currently supported. Supplying more than one will return 400 Bad Request");await this.putRequest("me/player",{device_ids:e,play:t})}async startResumePlayback(e,t,s,a,r){const o=this.paramsFor({device_id:e});await this.putRequest(`me/player/play${o}`,{context_uri:t,uris:s,offset:a,positionMs:r})}async pausePlayback(e){const t=this.paramsFor({device_id:e});await this.putRequest(`me/player/pause${t}`)}async skipToNext(e){const t=this.paramsFor({device_id:e});await this.postRequest(`me/player/next${t}`)}async skipToPrevious(e){const t=this.paramsFor({device_id:e});await this.postRequest(`me/player/previous${t}`)}async seekToPosition(e,t){const s=this.paramsFor({position_ms:e,device_id:t});await this.putRequest(`me/player/seek${s}`)}async setRepeatMode(e,t){const s=this.paramsFor({state:e,device_id:t});await this.putRequest(`me/player/repeat${s}`)}async setPlaybackVolume(e,t){const s=this.paramsFor({volume_percent:e,device_id:t});await this.putRequest(`me/player/volume${s}`)}async togglePlaybackShuffle(e,t){const s=this.paramsFor({state:e,device_id:t});await this.putRequest(`me/player/shuffle${s}`)}async addItemToPlaybackQueue(e,t){const s=this.paramsFor({uri:e,device_id:t});await this.postRequest(`me/player/queue${s}`)}}class U extends i{getPlaylist(e,t,s,a){const r=this.paramsFor({market:t,fields:s,additional_types:a?.join(",")});return this.getRequest(`playlists/${e}${r}`)}getPlaylistItems(e,t,s,a,r,o){const h=this.paramsFor({market:t,fields:s,limit:a,offset:r,additional_types:o?.join(",")});return this.getRequest(`playlists/${e}/tracks${h}`)}async changePlaylistDetails(e,t){await this.putRequest(`playlists/${e}`,t)}movePlaylistItems(e,t,s,a){return this.updatePlaylistItems(e,{range_start:t,range_length:s,insert_before:a})}updatePlaylistItems(e,t){return this.putRequest(`playlists/${e}/tracks`,t)}async addItemsToPlaylist(e,t,s){await this.postRequest(`playlists/${e}/tracks`,{position:s,uris:t})}async removeItemsFromPlaylist(e,t){await this.deleteRequest(`playlists/${e}/tracks`,t)}getUsersPlaylists(e,t,s){const a=this.paramsFor({limit:t,offset:s});return this.getRequest(`users/${e}/playlists${a}`)}createPlaylist(e,t){return this.postRequest(`users/${e}/playlists`,t)}getPlaylistCoverImage(e){return this.getRequest(`playlists/${e}/images`)}async addCustomPlaylistCoverImage(e,t){let s="";if(t instanceof Buffer)s=t.toString("base64");else if(t instanceof HTMLCanvasElement)s=t.toDataURL("image/jpeg").split(";base64,")[1];else if(t instanceof HTMLImageElement){const a=document.createElement("canvas");a.width=t.width,a.height=t.height;const r=a.getContext("2d");if(!r)throw new Error("Could not get canvas context");r.drawImage(t,0,0),s=a.toDataURL("image/jpeg").split(";base64,")[1]}else if(typeof t=="string")s=t;else throw new Error("ImageData must be a Buffer, HTMLImageElement, HTMLCanvasElement, or string containing a base64 encoded jpeg");await this.addCustomPlaylistCoverImageFromBase64String(e,s)}async addCustomPlaylistCoverImageFromBase64String(e,t){await this.putRequest(`playlists/${e}/images`,t,"image/jpeg")}}class _ extends i{async execute(e,t,s,a,r,o){const h=this.paramsFor({q:e,type:t,market:s,limit:a,offset:r,include_external:o});return await this.getRequest(`search${h}`)}}class B extends i{async get(e,t){if(typeof e=="string"){const r=this.paramsFor({market:t});return this.getRequest(`shows/${e}${r}`)}const s=this.paramsFor({ids:e,market:t});return(await this.getRequest(`shows${s}`)).shows}episodes(e,t,s,a){const r=this.paramsFor({market:t,limit:s,offset:a});return this.getRequest(`shows/${e}/episodes${r}`)}}class L extends i{async get(e,t){if(typeof e=="string"){const r=this.paramsFor({market:t});return this.getRequest(`tracks/${e}${r}`)}const s=this.paramsFor({ids:e,market:t});return(await this.getRequest(`tracks${s}`)).tracks}async audioFeatures(e){if(typeof e=="string")return this.getRequest(`audio-features/${e}`);const t=this.paramsFor({ids:e});return(await this.getRequest(`audio-features${t}`)).audio_features}audioAnalysis(e){return this.getRequest(`audio-analysis/${e}`)}}const R={access_token:"emptyAccessToken",token_type:"",expires_in:0,refresh_token:"",expires:-1};function m(n){return n===R}class O extends i{profile(e){return this.getRequest(`users/${e}`)}}class j extends i{albums;audiobooks;episodes;playlists;shows;tracks;constructor(e){super(e),this.albums=new N(e),this.audiobooks=new D(e),this.episodes=new M(e),this.playlists=new z(e),this.shows=new V(e),this.tracks=new H(e)}profile(){return this.getRequest("me")}topItems(e,t,s,a){const r=this.paramsFor({time_range:t,limit:s,offset:a});return this.getRequest(`me/top/${e}${r}`)}followedArtists(e,t){const s=this.paramsFor({type:"artist",after:e,limit:t});return this.getRequest(`me/following${s}`)}async followArtistsOrUsers(e,t){const s=this.paramsFor({type:t});await this.putRequest(`me/following${s}`,{ids:e})}async unfollowArtistsOrUsers(e,t){const s=this.paramsFor({type:t});await this.deleteRequest(`me/following${s}`,{ids:e})}followsArtistsOrUsers(e,t){const s=this.paramsFor({ids:e,type:t});return this.getRequest(`me/following/contains${s}`)}}class N extends i{savedAlbums(e,t,s){const a=this.paramsFor({limit:e,offset:t,market:s});return this.getRequest(`me/albums${a}`)}async saveAlbums(e){await this.putRequest("me/albums",e)}async removeSavedAlbums(e){await this.deleteRequest("me/albums",e)}hasSavedAlbums(e){const t=this.paramsFor({ids:e});return this.getRequest(`me/albums/contains${t}`)}}class D extends i{savedAudiobooks(e,t){const s=this.paramsFor({limit:e,offset:t});return this.getRequest(`me/audiobooks${s}`)}async saveAudiobooks(e){await this.putRequest("me/audiobooks",e)}async removeSavedAudiobooks(e){await this.deleteRequest("me/audiobooks",e)}hasSavedAudiobooks(e){const t=this.paramsFor({ids:e});return this.getRequest(`me/audiobooks/contains${t}`)}}class M extends i{savedEpisodes(e,t,s){const a=this.paramsFor({market:e,limit:t,offset:s});return this.getRequest(`me/episodes${a}`)}async saveEpisodes(e){await this.putRequest("me/episodes",e)}async removeSavedEpisodes(e){await this.deleteRequest("me/episodes",e)}hasSavedEpisodes(e){const t=this.paramsFor({ids:e});return this.getRequest(`me/episodes/contains${t}`)}}class z extends i{playlists(e,t){const s=this.paramsFor({limit:e,offset:t});return this.getRequest(`me/playlists${s}`)}async follow(e){await this.putRequest(`playlists/${e}/followers`)}async unfollow(e){await this.deleteRequest(`playlists/${e}/followers`)}isFollowing(e,t){const s=this.paramsFor({ids:t});return this.getRequest(`playlists/${e}/followers/contains${s}`)}}class V extends i{savedShows(e,t){const s=this.paramsFor({limit:e,offset:t});return this.getRequest(`me/shows${s}`)}saveShows(e){const t=this.paramsFor({ids:e});return this.putRequest(`me/shows${t}`)}removeSavedShows(e,t){const s=this.paramsFor({ids:e,market:t});return this.deleteRequest(`me/shows${s}`)}hasSavedShow(e){const t=this.paramsFor({ids:e});return this.getRequest(`me/shows/contains${t}`)}}class H extends i{savedTracks(e,t,s){const a=this.paramsFor({limit:e,offset:t,market:s});return this.getRequest(`me/tracks${a}`)}async saveTracks(e){await this.putRequest("me/tracks",e)}async removeSavedTracks(e){await this.deleteRequest("me/tracks",e)}hasSavedTracks(e){const t=this.paramsFor({ids:e});return this.getRequest(`me/tracks/contains${t}`)}}class J{static get current(){return this.hasSubtleCrypto?window.crypto:this.tryLoadNodeWebCrypto()}static get hasSubtleCrypto(){return typeof window<"u"&&typeof window.crypto<"u"&&typeof window.crypto.subtle<"u"}static tryLoadNodeWebCrypto(){try{const{webcrypto:e}=require("crypto");return e}catch(e){throw e}}}class u{static async refreshCachedAccessToken(e,t){const s=await u.refreshToken(e,t.refresh_token);return u.toCachable(s)}static toCachable(e){return e.expires&&e.expires===-1?e:{...e,expires:this.calculateExpiry(e)}}static calculateExpiry(e){return Date.now()+e.expires_in*1e3}static async refreshToken(e,t){const s=new URLSearchParams;s.append("client_id",e),s.append("grant_type","refresh_token"),s.append("refresh_token",t);const a=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:s}),r=await a.text();if(!a.ok)throw new Error(`Failed to refresh token: ${a.statusText}, ${r}`);return JSON.parse(r)}static generateCodeVerifier(e){let t="",s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";for(let a=0;a<e;a++)t+=s.charAt(Math.floor(Math.random()*s.length));return t}static async generateCodeChallenge(e){const t=new TextEncoder().encode(e),s=await J.current.subtle.digest("SHA-256",t),a=[...new Uint8Array(s)];return(typeof Buffer<"u"?Buffer.from(s).toString("base64"):btoa(String.fromCharCode.apply(null,a))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}}class y{clientId;clientSecret;scopes;static cacheKey="spotify-sdk:ClientCredentialsStrategy:token";configuration=null;get cache(){return this.configuration.cachingStrategy}constructor(e,t,s=[]){this.clientId=e,this.clientSecret=t,this.scopes=s}setConfiguration(e){this.configuration=e}async getOrCreateAccessToken(){return await this.cache.getOrCreate(y.cacheKey,async()=>{const t=await this.getTokenFromApi();return u.toCachable(t)},async t=>{const s=await this.getTokenFromApi();return u.toCachable(s)})}async getAccessToken(){return await this.cache.get(y.cacheKey)}removeAccessToken(){this.cache.remove(y.cacheKey)}async getTokenFromApi(){const e={grant_type:"client_credentials",scope:this.scopes.join(" ")},t=Object.keys(e).map(c=>c+"="+e[c]).join("&"),s=typeof Buffer<"u",a=`${this.clientId}:${this.clientSecret}`,r=s?Buffer.from(a).toString("base64"):btoa(a),o=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded",Authorization:`Basic ${r}`},body:t});if(o.status!==200)throw new Error("Failed to get access token.");return await o.json()}}class f{clientId;redirectUri;scopes;static cacheKey="spotify-sdk:ImplicitGrantStrategy:token";configuration=null;get cache(){return this.configuration.cachingStrategy}constructor(e,t,s){this.clientId=e,this.redirectUri=t,this.scopes=s}setConfiguration(e){this.configuration=e}async getOrCreateAccessToken(){return await this.cache.getOrCreate(f.cacheKey,async()=>{const t=await this.redirectOrVerifyToken();return u.toCachable(t)},async t=>u.refreshCachedAccessToken(this.clientId,t))}async getAccessToken(){return await this.cache.get(f.cacheKey)}removeAccessToken(){this.cache.remove(f.cacheKey)}async redirectOrVerifyToken(){const e=new URLSearchParams(window.location.hash.substring(1)),t=e.get("access_token");if(t)return Promise.resolve({access_token:t,token_type:e.get("token_type")??"",expires_in:parseInt(e.get("expires_in")??"0"),refresh_token:e.get("refresh_token")??"",expires:Number(e.get("expires"))||0});var a=(this.scopes??[]).join(" ");const r=new URLSearchParams;r.append("client_id",this.clientId),r.append("response_type","token"),r.append("redirect_uri",this.redirectUri),r.append("scope",a);const o="https://accounts.spotify.com/authorize?"+r.toString();return this.configuration.redirectionStrategy.redirect(o),R}}class d{clientId;redirectUri;scopes;static cacheKey="spotify-sdk:AuthorizationCodeWithPKCEStrategy:token";configuration=null;get cache(){return this.configuration.cachingStrategy}constructor(e,t,s){this.clientId=e,this.redirectUri=t,this.scopes=s}setConfiguration(e){this.configuration=e}async getOrCreateAccessToken(){return await this.cache.getOrCreate(d.cacheKey,async()=>{const t=await this.redirectOrVerifyToken();return u.toCachable(t)},async t=>u.refreshCachedAccessToken(this.clientId,t))}async getAccessToken(){return await this.cache.get(d.cacheKey)}removeAccessToken(){this.cache.remove(d.cacheKey)}async redirectOrVerifyToken(){const t=new URLSearchParams(window.location.search).get("code");if(t){const s=await this.verifyAndExchangeCode(t);return this.removeCodeFromUrl(),s}return this.redirectToSpotify(),R}async redirectToSpotify(){const e=u.generateCodeVerifier(128),t=await u.generateCodeChallenge(e),s={verifier:e,expiresOnAccess:!0};this.cache.setCacheItem("spotify-sdk:verifier",s);const a=await this.generateRedirectUrlForUser(this.scopes,t);await this.configuration.redirectionStrategy.redirect(a)}async verifyAndExchangeCode(e){const s=(await this.cache.get("spotify-sdk:verifier"))?.verifier;if(!s)throw new Error("No verifier found in cache - can't validate query string callback parameters.");return await this.configuration.redirectionStrategy.onReturnFromRedirect(),await this.exchangeCodeForToken(e,s)}removeCodeFromUrl(){const e=new URL(window.location.href);e.searchParams.delete("code");const t=e.search?e.href:e.href.replace("?","");window.history.replaceState({},document.title,t)}async generateRedirectUrlForUser(e,t){const s=e.join(" "),a=new URLSearchParams;return a.append("client_id",this.clientId),a.append("response_type","code"),a.append("redirect_uri",this.redirectUri),a.append("scope",s),a.append("code_challenge_method","S256"),a.append("code_challenge",t),`https://accounts.spotify.com/authorize?${a.toString()}`}async exchangeCodeForToken(e,t){const s=new URLSearchParams;s.append("client_id",this.clientId),s.append("grant_type","authorization_code"),s.append("code",e),s.append("redirect_uri",this.redirectUri),s.append("code_verifier",t);const a=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:s}),r=await a.text();if(!a.ok)throw new Error(`Failed to exchange code for token: ${a.statusText}, ${r}`);return JSON.parse(r)}}class W{async deserialize(e){const t=await e.text();return t.length>0?JSON.parse(t):null}}class K{async validateResponse(e){switch(e.status){case 401:throw new Error("Bad or expired token. This can happen if the user revoked a token or the access token has expired. You should re-authenticate the user.");case 403:const t=await e.text();throw new Error(`Bad OAuth request (wrong consumer key, bad nonce, expired timestamp...). Unfortunately, re-authenticating the user won't help here. Body: ${t}`);case 429:throw new Error("The app has exceeded its rate limits.");default:if(!e.status.toString().startsWith("20")){const s=await e.text();throw new Error(`Unrecognised response code: ${e.status} - ${e.statusText}. Body: ${s}`)}}}}class G{async handleErrors(e){return!1}}class Q{async redirect(e){document.location=e.toString()}async onReturnFromRedirect(){}}class S{storage;updateFunctions;autoRenewInterval;autoRenewWindow;constructor(e,t=new Map,s=0,a=120*1e3){this.storage=e,this.updateFunctions=t,this.autoRenewInterval=s,this.autoRenewWindow=a,this.autoRenewInterval>0&&setInterval(()=>this.autoRenewRenewableItems(),this.autoRenewInterval)}async getOrCreate(e,t,s){s&&this.updateFunctions.set(e,s);const a=await this.get(e);if(a)return a;const r=await t();if(!r)throw new Error("Could not create cache item");return m(r)||this.setCacheItem(e,r),r}async get(e){let t=this.storage.get(e),s=t?JSON.parse(t):null;if(this.itemDueToExpire(s)&&this.updateFunctions.has(e)){const a=this.updateFunctions.get(e);await this.tryUpdateItem(e,s,a),t=this.storage.get(e),s=t?JSON.parse(t):null}return s?s.expires&&(s.expires===-1||s.expires<=Date.now())?(this.remove(e),null):(s.expiresOnAccess&&s.expiresOnAccess===!0&&this.remove(e),s):null}set(e,t,s){const a=Date.now()+s,r={...t,expires:a};this.setCacheItem(e,r)}setCacheItem(e,t){const s=JSON.stringify(t);this.storage.set(e,s)}remove(e){this.storage.remove(e)}itemDueToExpire(e){return!e||!e.expires?!1:e.expires-Date.now()<this.autoRenewWindow}async autoRenewRenewableItems(){this.updateFunctions.forEach(async(e,t)=>{const s=await this.get(t);s&&e&&this.itemDueToExpire(s)&&await this.tryUpdateItem(t,s,e)})}async tryUpdateItem(e,t,s){try{const a=await s(t);a&&this.setCacheItem(e,a)}catch(a){console.error(a)}}}class Y extends S{constructor(){super(new X)}}class X{get(e){return localStorage.getItem(e)}set(e,t){localStorage.setItem(e,t)}remove(e){localStorage.removeItem(e)}}class Z extends S{constructor(){super(new ee)}}class ee{cache=new Map;get(e){return this.cache.get(e)??null}set(e,t){this.cache.set(e,t)}remove(e){this.cache.delete(e)}}class te{clientId;accessToken;refreshTokenAction;constructor(e,t,s){this.clientId=e,this.accessToken=t,this.refreshTokenAction=s||u.refreshCachedAccessToken,this.accessToken.expires||(this.accessToken.expires=u.calculateExpiry(this.accessToken))}setConfiguration(e){}async getOrCreateAccessToken(){if(this.accessToken.expires&&this.accessToken.expires<=Date.now()){const e=await this.refreshTokenAction(this.clientId,this.accessToken);this.accessToken=e}return this.accessToken}async getAccessToken(){return this.accessToken}removeAccessToken(){this.accessToken={access_token:"",token_type:"",expires_in:0,refresh_token:"",expires:0}}}class l{sdkConfig;static rootUrl="https://api.spotify.com/v1/";authenticationStrategy;albums;artists;audiobooks;browse;chapters;episodes;recommendations;markets;player;playlists;shows;tracks;users;search;currentUser;constructor(e,t){this.sdkConfig=this.initializeSdk(t),this.albums=new $(this),this.artists=new q(this),this.audiobooks=new x(this),this.browse=new F(this),this.chapters=new v(this),this.episodes=new A(this),this.recommendations=new E(this),this.markets=new P(this),this.player=new I(this),this.playlists=new U(this),this.shows=new B(this),this.tracks=new L(this),this.users=new O(this),this.currentUser=new j(this);const s=new _(this);this.search=s.execute.bind(s),this.authenticationStrategy=e,this.authenticationStrategy.setConfiguration(this.sdkConfig)}async makeRequest(e,t,s=void 0,a=void 0){try{const r=await this.authenticationStrategy.getOrCreateAccessToken();if(m(r))return console.warn("No access token found, authenticating now."),null;const o=r?.access_token,h=l.rootUrl+t,c={method:e,headers:{Authorization:`Bearer ${o}`,"Content-Type":a??"application/json"},body:s?typeof s=="string"?s:JSON.stringify(s):void 0};this.sdkConfig.beforeRequest(h,c);const w=await this.sdkConfig.fetch(h,c);return this.sdkConfig.afterRequest(h,c,w),w.status===204?null:(await this.sdkConfig.responseValidator.validateResponse(w),this.sdkConfig.deserializer.deserialize(w))}catch(r){if(!await this.sdkConfig.errorHandler.handleErrors(r))throw r;return null}}initializeSdk(e){const t=typeof window<"u";return{...{fetch:(a,r)=>fetch(a,r),beforeRequest:(a,r)=>{},afterRequest:(a,r,o)=>{},deserializer:new W,responseValidator:new K,errorHandler:new G,redirectionStrategy:new Q,cachingStrategy:t?new Y:new Z},...e}}switchAuthenticationStrategy(e){this.authenticationStrategy=e,this.authenticationStrategy.setConfiguration(this.sdkConfig),this.authenticationStrategy.getOrCreateAccessToken()}async authenticate(){const e=await this.authenticationStrategy.getOrCreateAccessToken();return{authenticated:e.expires>Date.now()&&!m(e),accessToken:e}}async getAccessToken(){return this.authenticationStrategy.getAccessToken()}logOut(){this.authenticationStrategy.removeAccessToken()}static withUserAuthorization(e,t,s=[],a){const r=new d(e,t,s);return new l(r,a)}static withClientCredentials(e,t,s=[],a){const r=new y(e,t,s);return new l(r,a)}static withImplicitGrant(e,t,s=[],a){const r=new f(e,t,s);return new l(r,a)}static withAccessToken(e,t,s){const a=new te(e,t);return new l(a,s)}static async performUserAuthorization(e,t,s,a,r){const o=new d(e,t,s),c=await new l(o,r).authenticationStrategy.getOrCreateAccessToken();return m(c)||(typeof a=="string"?(console.log("Posting access token to postback URL."),await fetch(a,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)})):await a(c)),{authenticated:c.expires>Date.now()&&!m(c),accessToken:c}}}class p{type="Song";title;artist;features;album;songID;progressSeconds;durationSeconds;albumArt;isPlaying;songChanged;constructor(){this.title="None",this.artist="None",this.features=[""],this.album="None",this.songID="0",this.progressSeconds=0,this.durationSeconds=0,this.albumArt=new Blob,this.isPlaying=!1,this.songChanged=!1}addTitle(e){this.title=e}addArtist(e){this.artist=e}addFeatures(e){this.features=e}addAlbum(e){this.album=e}addID(e){this.songID=e}addProgressSeconds(e){this.progressSeconds=e}addDurationSeconds(e){this.durationSeconds=e}addArt(e){this.albumArt=e}addisPlaying(e){this.isPlaying=e}toggleisPlaying(){this.isPlaying=!this.isPlaying}addChangedState(e){this.songChanged=e}toggleSongChanged(){this.songChanged=!this.songChanged}}class se{async downloadImage(e){const t=await fetch(e);if(!t.ok)throw new Error(`Failed to fetch image: ${t.statusText}`);return await t.blob()}async downloadImageAsBase64(e){const t=await T(e);return new Promise((s,a)=>{const r=new FileReader;r.onloadend=()=>s(r.result),r.onerror=a,r.readAsDataURL(t)})}}const b=new se,T=b.downloadImage.bind(b);let k;async function ae(){k=l.withUserAuthorization(g.CLIENT_ID,g.REDIRECT_URI,g.SCOPE),await k.getAccessToken()?console.log("Access token acquired successfully."):(console.log("No token found. Redirecting to Spotify for authorization..."),await k.authenticate())}class re{ALBUM_ART_PATH="../src/assets/current_album_art.jpg";REDIRECT_URI=`${window.location.origin}/`;CLIENT_ID="29a961338df9480db3c1b50e10df184f";SCOPE=["user-modify-playback-state","user-read-playback-state"];currentSong=new p;lastSong=new p;async fetchCurrentTrack(){let e;try{e=await k.player.getCurrentlyPlayingTrack()}catch(t){return console.error("Failed to fetch currently playing track:",t),new p}if(!e||!e.item)return console.log("User is not playing anything currently."),new p;if(e.item.type==="track"){const t=e.item;if(t.id!==this.lastSong.songID){const s=new p;s.addID(t.id),s.addisPlaying(e.is_playing),s.addTitle(t.name);const a=t.artists.map(r=>r.name);return s.addArtist(a[0]),s.addFeatures(a.slice(1)),s.addAlbum(t.album.name),s.addDurationSeconds(t.duration_ms/1e3),s.addProgressSeconds(e.progress_ms/1e3),s.addArt(await this.fetchAlbumArt(t)),s.addChangedState(!0),s.isPlaying?console.log(`Now Playing: ${s.title} by ${s.artist}`+(s.features.length?`, featuring ${s.features.join(", ")}`:"")):console.log(`Paused: ${s.title} by ${s.artist}`+(s.features.length?`, featuring ${s.features.join(", ")}`:"")),this.lastSong=s,this.currentSong=s,s}else return this.lastSong.addisPlaying(e.is_playing),this.lastSong.addProgressSeconds(e.progress_ms/1e3),this.lastSong.addChangedState(!1),this.currentSong=this.lastSong,this.lastSong}else if(e.item.type==="episode"){const t=e.item,s=new p;return s.type="Episode",s.addTitle(t.name),s.addID(t.id),console.log(`Now Playing Episode: ${t.name} (Show: ${t.show.name})`),this.currentSong=s,s}return console.log("Broken somehow, return outside of logic"),new p}async fetchAlbumArt(e){let t=e.album.images;if(t.length>1){const s=t[1].url;console.log("Found image, returning blob");let a=await T(s);const r=document.getElementById("album-art");return r&&(r.src=URL.createObjectURL(a)),a}return console.log("Track is not a song and doesn't have art. Returning blank"),new Blob}}const g=new re;g.fetchCurrentTrack.bind(g);class ne{constructor(){document.addEventListener("visibilitychange",()=>{document.hidden?this.stopPolling():this.startPolling()})}isPolling=!1;pollingTimeout;async startPolling(){this.isPolling||(this.isPolling=!0,this.poll())}stopPolling(){this.isPolling=!1,this.pollingTimeout&&(clearTimeout(this.pollingTimeout),this.pollingTimeout=void 0)}async poll(){if(this.isPolling){try{await this.fetchCurrentSong()}catch(e){console.error("Error fetching song:",e)}this.isPolling&&(this.pollingTimeout=window.setTimeout(()=>this.poll(),500))}}async fetchCurrentSong(){let e=await g.fetchCurrentTrack();return this.updateHTML(e),e}formatTime(e){const t=Math.floor(e/60),s=Math.floor(e%60);return`${t}:${s.toString().padStart(2,"0")}`}async updateHTML(e){document.getElementById("track-name").textContent=e.title,document.getElementById("artist-name").textContent=e.artist,document.getElementById("album-name").textContent=e.album,document.getElementById("track-progress").textContent=this.formatTime(e.progressSeconds),document.getElementById("track-duration").textContent=this.formatTime(e.durationSeconds);const t=document.getElementById("album-art");t&&(t.src=URL.createObjectURL(e.albumArt))}}const C=new ne;async function oe(){await ae(),C.startPolling()}oe();document.getElementById("fetchTrackButton").addEventListener("click",()=>{C.fetchCurrentSong()});
